"use strict";(globalThis.webpackChunkwax_docs=globalThis.webpackChunkwax_docs||[]).push([[599],{5958(e,r,n){n.r(r),n.d(r,{assets:()=>o,contentTitle:()=>d,default:()=>a,frontMatter:()=>c,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"core/wal-crash-recovery","title":"WAL & Crash Recovery","description":"How the write-ahead log ring buffer ensures durability and enables crash recovery.","source":"@site/docs/core/wal-crash-recovery.md","sourceDirName":"core","slug":"/core/wal-crash-recovery","permalink":"/docs/core/wal-crash-recovery","draft":false,"unlisted":false,"editUrl":"https://github.com/christopherkarani/Wax/tree/main/website/docs/core/wal-crash-recovery.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"WAL & Crash Recovery","sidebar_label":"WAL & Crash Recovery"},"sidebar":"docs","previous":{"title":"File Format","permalink":"/docs/core/file-format"},"next":{"title":"Structured Memory","permalink":"/docs/core/structured-memory"}}');var t=n(4848),i=n(8453);const c={sidebar_position:3,title:"WAL & Crash Recovery",sidebar_label:"WAL & Crash Recovery"},d=void 0,o={},l=[{value:"Overview",id:"overview",level:2},{value:"Ring Buffer Architecture",id:"ring-buffer-architecture",level:2},{value:"WAL Records",id:"wal-records",level:2},{value:"WAL Entries",id:"wal-entries",level:2},{value:"Fsync Policies",id:"fsync-policies",level:2},{value:"Crash Recovery",id:"crash-recovery",level:2},{value:"Proactive Commit",id:"proactive-commit",level:2},{value:"Replay State Snapshots",id:"replay-state-snapshots",level:2},{value:"Checksum Verification",id:"checksum-verification",level:2}];function h(e){const r={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.p,{children:"How the write-ahead log ring buffer ensures durability and enables crash recovery."}),"\n",(0,t.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(r.p,{children:"The WAL (Write-Ahead Log) is a fixed-size circular ring buffer that records all mutations before they are committed to the main file structure. This design ensures that:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsx)(r.li,{children:"A crash at any point never corrupts the store"}),"\n",(0,t.jsx)(r.li,{children:"Uncommitted mutations are automatically replayed on next open"}),"\n",(0,t.jsx)(r.li,{children:"Writes can be batched for performance without sacrificing durability"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"ring-buffer-architecture",children:"Ring Buffer Architecture"}),"\n",(0,t.jsx)(r.p,{children:"The WAL occupies a contiguous region starting at file offset 8 KiB. Its default size is 256 MiB, configurable at creation time. The ring buffer uses two pointers:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Write position"})," \u2014 where the next record will be written"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Checkpoint position"})," \u2014 the boundary of committed records"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["Records between the checkpoint and write positions are ",(0,t.jsx)(r.strong,{children:"pending"})," (uncommitted). On commit, the checkpoint advances to match the write position."]}),"\n",(0,t.jsx)(r.h2,{id:"wal-records",children:"WAL Records"}),"\n",(0,t.jsx)(r.p,{children:"Each WAL record has a 48-byte header:"}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Offset"}),(0,t.jsx)(r.th,{children:"Type"}),(0,t.jsx)(r.th,{children:"Field"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"0\u20137"}),(0,t.jsx)(r.td,{children:"UInt64"}),(0,t.jsx)(r.td,{children:"Sequence number (monotonically increasing)"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"8\u201311"}),(0,t.jsx)(r.td,{children:"UInt32"}),(0,t.jsx)(r.td,{children:"Payload length"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"12\u201315"}),(0,t.jsx)(r.td,{children:"UInt32"}),(0,t.jsx)(r.td,{children:"Flags (bit 0 = isPadding)"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:"16\u201347"}),(0,t.jsx)(r.td,{children:"32 bytes"}),(0,t.jsx)(r.td,{children:"Payload checksum (SHA-256)"})]})]})]}),"\n",(0,t.jsx)(r.p,{children:"Records come in three types:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Data"})," \u2014 Contains a mutation payload (frame put, delete, supersede, or embedding) with a SHA-256 checksum"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Padding"})," \u2014 Fills gaps when there isn't enough space at the ring's end for a new record; the ring wraps around"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Sentinel"})," \u2014 All-zero marker indicating the end of valid records"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"wal-entries",children:"WAL Entries"}),"\n",(0,t.jsxs)(r.p,{children:["Each data record's payload encodes a ",(0,t.jsx)(r.code,{children:"WALEntry"})," with an opcode:"]}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Opcode"}),(0,t.jsx)(r.th,{children:"Entry"}),(0,t.jsx)(r.th,{children:"Description"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"0x01"})}),(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"putFrame"})}),(0,t.jsx)(r.td,{children:"Store frame metadata and payload reference"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"0x02"})}),(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"deleteFrame"})}),(0,t.jsx)(r.td,{children:"Mark a frame as deleted"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"0x03"})}),(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"supersedeFrame"})}),(0,t.jsx)(r.td,{children:"Link an older frame to its replacement"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"0x04"})}),(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:"putEmbedding"})}),(0,t.jsx)(r.td,{children:"Store a vector embedding for a frame"})]})]})]}),"\n",(0,t.jsx)(r.h2,{id:"fsync-policies",children:"Fsync Policies"}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"WALFsyncPolicy"})," controls when writes are flushed to disk:"]}),"\n",(0,t.jsxs)(r.table,{children:[(0,t.jsx)(r.thead,{children:(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.th,{children:"Policy"}),(0,t.jsx)(r.th,{children:"Behavior"})]})}),(0,t.jsxs)(r.tbody,{children:[(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:".always"})}),(0,t.jsx)(r.td,{children:"Fsync after every write (safest, slowest)"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:".onCommit"})}),(0,t.jsx)(r.td,{children:"Fsync only when the WAL is checkpointed"})]}),(0,t.jsxs)(r.tr,{children:[(0,t.jsx)(r.td,{children:(0,t.jsx)(r.code,{children:".everyBytes(threshold)"})}),(0,t.jsx)(r.td,{children:"Fsync after accumulating a threshold of bytes"})]})]})]}),"\n",(0,t.jsxs)(r.p,{children:["Choose based on your durability requirements. ",(0,t.jsx)(r.code,{children:".everyBytes(1_048_576)"})," (1 MiB) is a good balance for most applications."]}),"\n",(0,t.jsx)(r.h2,{id:"crash-recovery",children:"Crash Recovery"}),"\n",(0,t.jsx)(r.p,{children:"When opening a store, WaxCore performs the following recovery sequence:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Header A/B selection"})," \u2014 Both header pages are read and validated. The page with the highest ",(0,t.jsx)(r.code,{children:"headerPageGeneration"})," that passes checksum validation is selected."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Replay snapshot check"})," \u2014 If the selected header contains a valid WAL replay snapshot (magic ",(0,t.jsx)(r.code,{children:"WALSNAP1"})," at offset 136), recovery can skip already-committed WAL records and resume from the snapshot's position. This significantly speeds up recovery for large WAL buffers."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"WAL scan"})," \u2014 Starting from the checkpoint position, the ",(0,t.jsx)(r.code,{children:"WALRingReader"})," scans forward through the ring buffer, reading all pending (uncommitted) records. Corrupted records in the pending region are tolerated \u2014 scanning continues for position tracking."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"State reconstruction"})," \u2014 Pending mutations are applied to rebuild in-memory indexes and frame metadata."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"proactive-commit",children:"Proactive Commit"}),"\n",(0,t.jsx)(r.p,{children:"WaxCore supports proactive commit thresholds to bound the amount of data at risk in the WAL:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-swift",children:"let options = WaxOptions(\n    proactiveCommitThreshold: 1024  // Auto-commit after 1024 pending entries\n)\n"})}),"\n",(0,t.jsx)(r.p,{children:"When the pending entry count exceeds this threshold, a commit is triggered automatically during the next write operation."}),"\n",(0,t.jsx)(r.h2,{id:"replay-state-snapshots",children:"Replay State Snapshots"}),"\n",(0,t.jsxs)(r.p,{children:["When ",(0,t.jsx)(r.code,{children:"enableReplayStateSnapshot"})," is set in ",(0,t.jsx)(r.code,{children:"WaxOptions"}),", the header stores a snapshot of the WAL state at the last commit. This snapshot includes:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"File generation"}),"\n",(0,t.jsx)(r.li,{children:"Committed sequence number"}),"\n",(0,t.jsx)(r.li,{children:"Footer offset"}),"\n",(0,t.jsx)(r.li,{children:"Write and checkpoint positions"}),"\n",(0,t.jsx)(r.li,{children:"Pending byte count"}),"\n",(0,t.jsx)(r.li,{children:"Last sequence number"}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"On recovery, this snapshot allows the reader to skip the committed portion of the WAL and start scanning from the snapshot's position, reducing recovery time from O(WAL size) to O(pending bytes)."}),"\n",(0,t.jsx)(r.h2,{id:"checksum-verification",children:"Checksum Verification"}),"\n",(0,t.jsx)(r.p,{children:"Every layer of the persistence stack uses SHA-256 checksums:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"WAL records"})," \u2014 SHA-256 of the payload bytes"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Header pages"})," \u2014 SHA-256 of the header with the checksum field zeroed"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"TOC"})," \u2014 SHA-256 of the TOC body, excluding the final 32 bytes, padded with 32 zero bytes"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Footer"})," \u2014 Validates that the TOC hash matches"]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"This multi-layer checksum strategy ensures that corruption is detected at every level."})]})}function a(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,r,n){n.d(r,{R:()=>c,x:()=>d});var s=n(6540);const t={},i=s.createContext(t);function c(e){const r=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);