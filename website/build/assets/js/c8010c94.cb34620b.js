"use strict";(globalThis.webpackChunkwax_docs=globalThis.webpackChunkwax_docs||[]).push([[727],{2626(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"orchestrator/session-management","title":"Session Management","description":"Use WaxSession for read/write multiplexing and understand writer policies.","source":"@site/docs/orchestrator/session-management.md","sourceDirName":"orchestrator","slug":"/orchestrator/session-management","permalink":"/docs/orchestrator/session-management","draft":false,"unlisted":false,"editUrl":"https://github.com/christopherkarani/Wax/tree/main/website/docs/orchestrator/session-management.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Session Management","sidebar_label":"Session Management"},"sidebar":"docs","previous":{"title":"Unified Search","permalink":"/docs/orchestrator/unified-search"},"next":{"title":"Photo RAG","permalink":"/docs/media/photo-rag"}}');var i=s(4848),r=s(8453);const a={sidebar_position:4,title:"Session Management",sidebar_label:"Session Management"},o=void 0,c={},d=[{value:"Overview",id:"overview",level:2},{value:"Session Modes",id:"session-modes",level:2},{value:"Read-Only",id:"read-only",level:3},{value:"Read-Write",id:"read-write",level:3},{value:"Writer Policies",id:"writer-policies",level:2},{value:"Session Configuration",id:"session-configuration",level:2},{value:"Frame Operations",id:"frame-operations",level:2},{value:"Search Operations",id:"search-operations",level:2},{value:"Text Indexing",id:"text-indexing",level:2},{value:"Structured Memory",id:"structured-memory",level:2},{value:"Lifecycle",id:"lifecycle",level:2},{value:"Staging and Committing",id:"staging-and-committing",level:3},{value:"Closing",id:"closing",level:3},{value:"Orchestrator Sessions",id:"orchestrator-sessions",level:2}];function l(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Use WaxSession for read/write multiplexing and understand writer policies."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"WaxSession"})," provides a unified interface for frame operations, search, and structured memory. It abstracts the difference between read-only and read-write access modes, managing writer leases automatically."]}),"\n",(0,i.jsx)(n.h2,{id:"session-modes",children:"Session Modes"}),"\n",(0,i.jsx)(n.h3,{id:"read-only",children:"Read-Only"}),"\n",(0,i.jsx)(n.p,{children:"Read-only sessions can search and read frames but cannot write:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:'let session = WaxSession(\n    wax: store,\n    mode: .readOnly,\n    config: .init()\n)\n\nlet results = try await session.searchText(query: "meeting", topK: 10)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Multiple read-only sessions can operate concurrently."}),"\n",(0,i.jsx)(n.h3,{id:"read-write",children:"Read-Write"}),"\n",(0,i.jsx)(n.p,{children:"Read-write sessions acquire a writer lease for exclusive write access:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:'let session = WaxSession(\n    wax: store,\n    mode: .readWrite(.wait),\n    config: .init()\n)\n\ntry await session.put(text: "New content", timestamp: nowMs)\ntry await session.commit()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Only one read-write session can be active at a time."}),"\n",(0,i.jsx)(n.h2,{id:"writer-policies",children:"Writer Policies"}),"\n",(0,i.jsx)(n.p,{children:"The writer policy determines what happens when another writer already holds the lease:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Policy"}),(0,i.jsx)(n.th,{children:"Behavior"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".wait"})}),(0,i.jsx)(n.td,{children:"Suspend until the lease becomes available (default)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".fail"})}),(0,i.jsx)(n.td,{children:"Immediately throw an error"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:".timeout(Duration)"})}),(0,i.jsx)(n.td,{children:"Wait up to a duration, then throw"})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:"// Fail immediately if another writer is active\nlet session = WaxSession(wax: store, mode: .readWrite(.fail))\n\n// Wait up to 5 seconds\nlet session = WaxSession(wax: store, mode: .readWrite(.timeout(.seconds(5))))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"session-configuration",children:"Session Configuration"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"WaxSession/Config"})," controls which search features are enabled:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:"var config = WaxSession.Config()\nconfig.enableTextSearch = true\nconfig.enableVectorSearch = true\nconfig.enableStructuredMemory = false\nconfig.vectorEnginePreference = .auto\nconfig.vectorMetric = .cosine\nconfig.vectorDimensions = 384\n"})}),"\n",(0,i.jsx)(n.h2,{id:"frame-operations",children:"Frame Operations"}),"\n",(0,i.jsx)(n.p,{children:"Write frames with various overloads:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:'// Simple text frame\ntry await session.put(text: "Hello world", timestamp: nowMs)\n\n// Frame with embedding\ntry await session.put(\n    text: "Semantic content",\n    timestamp: nowMs,\n    embedding: vectorData\n)\n\n// Batch write\ntry await session.putBatch(\n    texts: ["doc1", "doc2", "doc3"],\n    timestamps: [ts1, ts2, ts3]\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"search-operations",children:"Search Operations"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"WaxSession"})," delegates search to the unified search system:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:'// Full unified search\nlet response = try await session.search(SearchRequest(\n    query: "architecture",\n    mode: .hybrid(alpha: 0.5),\n    topK: 20\n))\n\n// Text-only search\nlet textResults = try await session.searchText(query: "architecture", topK: 10)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"text-indexing",children:"Text Indexing"}),"\n",(0,i.jsx)(n.p,{children:"Manage the FTS5 text index directly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:'// Index a frame\'s text\ntry await session.indexText(frameId: 42, text: "Indexed content")\n\n// Batch indexing\ntry await session.indexTextBatch(\n    frameIds: [1, 2, 3],\n    texts: ["First", "Second", "Third"]\n)\n\n// Remove from index\ntry await session.removeText(frameId: 42)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"structured-memory",children:"Structured Memory"}),"\n",(0,i.jsx)(n.p,{children:"Access the knowledge graph through the session:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:'let entityId = try await session.upsertEntity(\n    key: EntityKey("alice"),\n    kind: "Person",\n    aliases: ["Alice S."],\n    nowMs: nowMs\n)\n\nlet factId = try await session.assertFact(\n    subject: EntityKey("alice"),\n    predicate: PredicateKey("title"),\n    object: .string("CTO"),\n    valid: StructuredTimeRange(fromMs: startMs, toMs: nil),\n    system: StructuredTimeRange(fromMs: nowMs, toMs: nil),\n    evidence: []\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,i.jsx)(n.h3,{id:"staging-and-committing",children:"Staging and Committing"}),"\n",(0,i.jsx)(n.p,{children:"Stage search indexes for persistence, then commit all changes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:"// Stage indexes (text + vector)\ntry await session.stage(compact: false)\n\n// Commit everything to disk\ntry await session.commit(compact: false)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"compact"})," flag triggers index compaction (VACUUM for SQLite, defragmentation for vectors) before staging."]}),"\n",(0,i.jsx)(n.h3,{id:"closing",children:"Closing"}),"\n",(0,i.jsx)(n.p,{children:"Always close sessions when done:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-swift",children:"try await session.close()\n"})}),"\n",(0,i.jsx)(n.p,{children:"This releases the writer lease (if held) and flushes any pending operations."}),"\n",(0,i.jsx)(n.h2,{id:"orchestrator-sessions",children:"Orchestrator Sessions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"MemoryOrchestrator"})," manages its own internal ",(0,i.jsx)(n.code,{children:"WaxSession"}),". You typically don't need to create sessions directly unless you need lower-level control. The orchestrator's ",(0,i.jsx)(n.code,{children:"MemoryOrchestrator/startSession()"})," and ",(0,i.jsx)(n.code,{children:"MemoryOrchestrator/endSession()"})," methods manage session tagging for analytics and handoff tracking."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);