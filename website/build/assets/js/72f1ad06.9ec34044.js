"use strict";(globalThis.webpackChunkwax_docs=globalThis.webpackChunkwax_docs||[]).push([[446],{4582(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"core/concurrency-model","title":"Concurrency Model","description":"Understand the actor-per-subsystem architecture, writer leases, and synchronization primitives.","source":"@site/docs/core/concurrency-model.md","sourceDirName":"core","slug":"/core/concurrency-model","permalink":"/docs/core/concurrency-model","draft":false,"unlisted":false,"editUrl":"https://github.com/christopherkarani/Wax/tree/main/website/docs/core/concurrency-model.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Concurrency Model","sidebar_label":"Concurrency Model"},"sidebar":"docs","previous":{"title":"Structured Memory","permalink":"/docs/core/structured-memory"},"next":{"title":"Text Search Engine","permalink":"/docs/text-search/text-search-engine"}}');var i=n(4848),c=n(8453);const o={sidebar_position:5,title:"Concurrency Model",sidebar_label:"Concurrency Model"},t=void 0,l={},a=[{value:"Overview",id:"overview",level:2},{value:"Actor Isolation",id:"actor-isolation",level:2},{value:"Writer Leases",id:"writer-leases",level:2},{value:"Synchronization Primitives",id:"synchronization-primitives",level:2},{value:"AsyncReadWriteLock",id:"asyncreadwritelock",level:3},{value:"AsyncMutex",id:"asyncmutex",level:3},{value:"ReadWriteLock",id:"readwritelock",level:3},{value:"UnfairLock",id:"unfairlock",level:3},{value:"FileLock",id:"filelock",level:3},{value:"BlockingIOExecutor",id:"blockingioexecutor",level:2},{value:"Cross-Process Safety",id:"cross-process-safety",level:2}];function d(e){const r={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.p,{children:"Understand the actor-per-subsystem architecture, writer leases, and synchronization primitives."}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(r.p,{children:["WaxCore uses an ",(0,i.jsx)(r.strong,{children:"actor-per-subsystem"})," concurrency model where each major component is an actor with its own serial executor. Shared mutable state is protected by purpose-built synchronization primitives, and I/O is offloaded to a concurrent dispatch queue."]}),"\n",(0,i.jsx)(r.h2,{id:"actor-isolation",children:"Actor Isolation"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"Wax"})," actor is the central coordinator. All frame reads and writes go through it, ensuring sequential consistency for mutations while allowing concurrent reads."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Wax (actor)                 \u2502\n\u2502                                     \u2502\n\u2502  AsyncReadWriteLock (opLock)        \u2502\n\u2502  \u251c\u2500\u2500 Readers: concurrent            \u2502\n\u2502  \u2514\u2500\u2500 Writer: exclusive (lease)      \u2502\n\u2502                                     \u2502\n\u2502  BlockingIOExecutor                 \u2502\n\u2502  \u251c\u2500\u2500 run<T>(): concurrent reads     \u2502\n\u2502  \u2514\u2500\u2500 runWrite<T>(): exclusive write \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(r.h2,{id:"writer-leases",children:"Writer Leases"}),"\n",(0,i.jsx)(r.p,{children:"Only one writer can be active at a time, enforced by a lease system:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-swift",children:"let lease = try await store.acquireWriterLease(policy: .wait)\n// ... perform writes ...\nstore.releaseWriterLease(lease)\n"})}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"WaxWriterPolicy"})," enum controls acquisition behavior:"]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Policy"}),(0,i.jsx)(r.th,{children:"Behavior"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:".fail"})}),(0,i.jsxs)(r.td,{children:["Throws ",(0,i.jsx)(r.code,{children:"WaxError/writerBusy"})," immediately"]})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:".wait"})}),(0,i.jsx)(r.td,{children:"Suspends until the lease becomes available"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:".timeout(Duration)"})}),(0,i.jsxs)(r.td,{children:["Waits up to a duration, then throws ",(0,i.jsx)(r.code,{children:"WaxError/writerTimeout"})]})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"synchronization-primitives",children:"Synchronization Primitives"}),"\n",(0,i.jsx)(r.p,{children:"WaxCore provides several lock types for different use cases:"}),"\n",(0,i.jsx)(r.h3,{id:"asyncreadwritelock",children:"AsyncReadWriteLock"}),"\n",(0,i.jsx)(r.p,{children:"An actor-based reader-writer lock using Swift continuations. Writers are prioritized over readers to prevent starvation."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-swift",children:"let lock = AsyncReadWriteLock()\nawait lock.readLock()\n// ... concurrent read ...\nlock.readUnlock()\n\nawait lock.writeLock()\n// ... exclusive write ...\nlock.writeUnlock()\n"})}),"\n",(0,i.jsx)(r.h3,{id:"asyncmutex",children:"AsyncMutex"}),"\n",(0,i.jsx)(r.p,{children:"A simple async mutual exclusion lock using continuations:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-swift",children:"let mutex = AsyncMutex()\nawait mutex.withLock {\n    // ... exclusive access ...\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"readwritelock",children:"ReadWriteLock"}),"\n",(0,i.jsxs)(r.p,{children:["A synchronous reader-writer lock backed by ",(0,i.jsx)(r.code,{children:"pthread_rwlock_t"}),". Used on hot paths where async overhead is unacceptable:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-swift",children:"let lock = ReadWriteLock()\nlock.readLock()\n// ... fast read ...\nlock.readUnlock()\n"})}),"\n",(0,i.jsx)(r.h3,{id:"unfairlock",children:"UnfairLock"}),"\n",(0,i.jsxs)(r.p,{children:["Minimal-overhead lock for the hottest paths. Uses ",(0,i.jsx)(r.code,{children:"os_unfair_lock"})," on Darwin and ",(0,i.jsx)(r.code,{children:"pthread_mutex_t"})," on Linux:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-swift",children:"let lock = UnfairLock()\nlock.withLock {\n    // ... critical section ...\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"filelock",children:"FileLock"}),"\n",(0,i.jsxs)(r.p,{children:["Advisory whole-file lock via POSIX ",(0,i.jsx)(r.code,{children:"flock"})," for cross-process synchronization:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-swift",children:"let lock = FileLock()\ntry lock.acquire(at: fileURL, mode: .exclusive)\n// ... exclusive file access ...\nlock.release()\n"})}),"\n",(0,i.jsx)(r.p,{children:"Supports shared (read) and exclusive (write) modes, plus upgrade and downgrade transitions."}),"\n",(0,i.jsx)(r.h2,{id:"blockingioexecutor",children:"BlockingIOExecutor"}),"\n",(0,i.jsxs)(r.p,{children:["The ",(0,i.jsx)(r.code,{children:"BlockingIOExecutor"})," offloads file I/O to a concurrent ",(0,i.jsx)(r.code,{children:"DispatchQueue"}),":"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Read operations"})," via ",(0,i.jsx)(r.code,{children:"run<T>()"})," execute concurrently with other reads"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Write operations"})," via ",(0,i.jsx)(r.code,{children:"runWrite<T>()"})," use a barrier flag for exclusivity"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"This separates the async actor world from blocking POSIX I/O, preventing actor thread pool exhaustion."}),"\n",(0,i.jsx)(r.h2,{id:"cross-process-safety",children:"Cross-Process Safety"}),"\n",(0,i.jsxs)(r.p,{children:["For multi-process access to the same ",(0,i.jsx)(r.code,{children:".mv2s"})," file, ",(0,i.jsx)(r.code,{children:"FileLock"})," provides advisory locking:"]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Multiple processes can hold ",(0,i.jsx)(r.strong,{children:"shared locks"})," for concurrent reads"]}),"\n",(0,i.jsxs)(r.li,{children:["A process requesting an ",(0,i.jsx)(r.strong,{children:"exclusive lock"})," for writes blocks until all shared locks are released"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Combined with the dual-header A/B mirroring, this ensures that a reader never sees a partially-written header even if the writer crashes mid-update."})]})}function h(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,r,n){n.d(r,{R:()=>o,x:()=>t});var s=n(6540);const i={},c=s.createContext(i);function o(e){const r=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function t(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(c.Provider,{value:r},e.children)}}}]);